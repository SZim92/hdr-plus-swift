name: CI

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.gitignore'
  pull_request:
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.gitignore'
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to test (comma-separated, e.g., "macos-14,macos-13")'
        required: false
        default: ''

# Prevent concurrent runs on the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  config:
    name: Setup Test Matrix
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.matrix-setup.outputs.platforms }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Load CI configuration
        id: matrix-setup
        run: |
          # Check if jq is installed, install if needed
          if ! command -v jq &>/dev/null; then
            echo "Installing jq..."
            apt-get update && apt-get install -y jq
          fi
          
          # Get the list of platforms from config file
          if [ -f ".github/workflows/shared/ci-config.yml" ]; then
            # Parse YAML with yq or another tool if available
            # For now, using hardcoded values or manual parsing
            
            # Default platforms (if file parsing fails)
            PLATFORM_DEFINITIONS=$(cat <<'EOF'
            [
              {"name": "macOS Sonoma (Apple Silicon)", "runner": "macos-14", "xcode": "15.2", "architecture": "arm64"},
              {"name": "macOS Ventura (Intel)", "runner": "macos-13", "xcode": "15.0", "architecture": "x86_64"}
            ]
            EOF
            )
          else
            # Fallback platforms
            PLATFORM_DEFINITIONS=$(cat <<'EOF'
            [
              {"name": "macOS Sonoma (Apple Silicon)", "runner": "macos-14", "xcode": "15.2", "architecture": "arm64"},
              {"name": "macOS Ventura (Intel)", "runner": "macos-13", "xcode": "15.0", "architecture": "x86_64"}
            ]
            EOF
            )
          fi
          
          # Apply platform filter if specified
          PLATFORM_FILTER="${{ github.event.inputs.platforms }}"
          if [ -n "$PLATFORM_FILTER" ]; then
            # Filter platforms based on input
            FILTERED_PLATFORMS="["
            IFS=',' read -ra FILTER_LIST <<< "$PLATFORM_FILTER"
            
            for platform in "${FILTER_LIST[@]}"; do
              case "$platform" in
                macos-14|sonoma)
                  # Extract the macOS 14 entry from PLATFORM_DEFINITIONS
                  echo "Including macOS Sonoma..."
                  FILTERED_PLATFORMS+=$(echo "$PLATFORM_DEFINITIONS" | jq '.[] | select(.runner == "macos-14")')
                  FILTERED_PLATFORMS+=","
                  ;;
                macos-13|ventura)
                  # Extract the macOS 13 entry from PLATFORM_DEFINITIONS
                  echo "Including macOS Ventura..."
                  FILTERED_PLATFORMS+=$(echo "$PLATFORM_DEFINITIONS" | jq '.[] | select(.runner == "macos-13")')
                  FILTERED_PLATFORMS+=","
                  ;;
                *)
                  echo "Ignoring unknown platform: $platform"
                  ;;
              esac
            done
            
            # Remove trailing comma and close array
            FILTERED_PLATFORMS="${FILTERED_PLATFORMS%,}]"
            
            # Use filtered platforms if not empty, otherwise use all
            if [ "$FILTERED_PLATFORMS" != "[]" ]; then
              PLATFORMS=$FILTERED_PLATFORMS
            else
              echo "No valid platforms specified, using all platforms"
              PLATFORMS=$PLATFORM_DEFINITIONS
            fi
          else
            # Use all platforms
            PLATFORMS=$PLATFORM_DEFINITIONS
          fi
          
          echo "Generated platform configuration:"
          echo "$PLATFORMS" | jq .
          
          # Output as compact JSON
          echo "platforms=$(echo "$PLATFORMS" | jq -c .)" >> $GITHUB_OUTPUT
        shell: bash
        
  lint:
    name: Lint Swift Code
    runs-on: macos-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Install SwiftLint
        run: |
          if ! command -v swiftlint &>/dev/null; then
            brew install swiftlint
          fi
      
      - name: Run SwiftLint
        run: |
          if [ -f ".swiftlint.yml" ]; then
            echo "Running SwiftLint with configuration file..."
            swiftlint lint --reporter github-actions-logging
          else
            echo "Running SwiftLint with default configuration..."
            swiftlint lint --strict --reporter github-actions-logging
          fi
        continue-on-error: true  # Allow the workflow to continue even if linting fails
  
  test:
    name: Test on ${{ matrix.platform.name }}
    needs: config
    strategy:
      fail-fast: false  # Continue with other platforms if one fails
      matrix:
        platform: ${{ fromJson(needs.config.outputs.platforms) }}
    
    uses: ./.github/workflows/shared/metal-testing.yml
    with:
      platform: ${{ matrix.platform.runner }}
      xcode-version: ${{ matrix.platform.xcode }}
      architecture: ${{ matrix.platform.architecture }}
  
  # Add visual regression testing for Metal rendering
  visual-testing:
    name: Metal Visual Regression
    # Only run on PRs with Metal or UI changes, or when manually triggered
    if: >
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'pull_request' && 
       (contains(github.event.pull_request.labels.*.name, 'area/metal') || 
        contains(github.event.pull_request.labels.*.name, 'area/ui')))
    needs: [config]
    runs-on: macos-14
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      # Add Metal shader compilation cache
      - name: Cache Metal shaders
        uses: actions/cache@v4
        with:
          path: .metal-cache
          key: metal-visual-${{ runner.os }}-${{ hashFiles('**/*.metal') }}
          restore-keys: |
            metal-visual-${{ runner.os }}-
      
      - name: Setup Metal environment
        run: |
          echo "Setting up environment for Metal testing"
          mkdir -p test-outputs/visual-tests
          # Make the render test script executable
          chmod +x tools/render-test-scenes.sh
        
      - name: Run visual test scene renderer
        run: |
          # Use the standardized script instead of embedded code
          echo "Generating test scenes using the shared renderer script..."
          ./tools/render-test-scenes.sh --count 5 --output test-outputs/visual-tests
          
      - name: Upload visual test results
        uses: actions/upload-artifact@v4
        with:
          name: visual-test-outputs
          path: test-outputs/visual-tests
          if-no-files-found: error
      
  summarize:
    name: Summarize Results
    needs: test
    if: always()  # Run even if tests fail
    
    uses: ./.github/workflows/shared/test-summarizer.yml
    
  notify:
    name: Notify on Completion
    needs: [lint, test, summarize]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Check workflow status
        id: check
        run: |
          if [ "${{ contains(needs.*.result, 'failure') }}" == "true" ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "icon=❌" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "icon=✅" >> $GITHUB_OUTPUT
          fi
      
      - name: Report status
        run: |
          echo "## CI Run Complete ${{ steps.check.outputs.icon }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Job Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Linting | ${{ needs.lint.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Testing | ${{ needs.test.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Summary | ${{ needs.summarize.result }} |" >> $GITHUB_STEP_SUMMARY
          
          # Add visual testing status if it was run (using proper job name existence check)
          if [[ "${{ contains(needs.*.name, 'Metal Visual Regression') }}" == "true" ]] && [[ -n "${{ needs.visual-testing.result }}" ]]; then
            echo "| Visual Testing | ${{ needs.visual-testing.result }} |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Overall status: **${{ steps.check.outputs.status }}**" >> $GITHUB_STEP_SUMMARY
          
  pr-feedback:
    name: PR Feedback
    # Only run for PR events
    if: github.event_name == 'pull_request'
    needs: [summarize]
    uses: ./.github/workflows/shared/enhanced-pr-feedback.yml
    with:
      pr-number: ${{ github.event.pull_request.number }}
      artifact-prefix: 'test-results-'
      include-metal-diagnostics: true
      include-visual-comparisons: ${{ contains(needs.*.result, 'visual-testing') && (needs.visual-testing.result == 'success' || needs.visual-testing.result == 'failure') }}
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }} 